Description: Upstream changes introduced in version 2.2.4-1
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 slurm-llnl (2.2.4-1) unstable; urgency=low
 .
   * New upstream releases
   * Cleaning spare file and directories, not belonging to the sources
     generated by the building process and not removed by distclean.
     Added debian/clean with spare files and rm -rf inside debian/rules
     for directories.
 .
 The person named in the Author field signed this changelog entry.
Author: Gennaro Oliva <oliva.g@na.icar.cnr.it>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- slurm-llnl-2.2.4.orig/NEWS
+++ slurm-llnl-2.2.4/NEWS
@@ -2924,7 +2924,7 @@ documents those changes that are of inte
     than one partition uses a node or there is more than one socket per node.
  -- In output for "scontrol show job" change "StartTime" header to "EligibleTime"
     for pending jobs to accurately describe what is reported.
- -- Add more slurmdbd.conf paramters: ArchiveScript, ArchiveAge, JobPurge, and
+ -- Add more slurmdbd.conf parameters: ArchiveScript, ArchiveAge, JobPurge, and
     StepPurge (not fully implemented yet).
  -- Add slurm.conf parameter EnforcePartLimits to reject jobs which exceed a
     partition's size and/or time limits rather than leaving them queued for a
@@ -3227,7 +3227,7 @@ documents those changes that are of inte
     removed!  That functionality is now available in the separate commands
     salloc, sbatch, and sattach, respectively.
  -- Add new node state FAILING plus trigger for when node enters that state.
- -- Add new configuration paramter "PrivateData". This can be used to 
+ -- Add new configuration parameter "PrivateData". This can be used to 
     prevent a user from seeing jobs or job steps belonging to other users.
  -- Added configuration parameters for node power save mode: ResumeProgram
     ResumeRate, SuspendExcNodes, SuspendExcParts, SuspendProgram and 
@@ -4140,7 +4140,7 @@ documents those changes that are of inte
  - BLUEGENE - check to make sure set_block_user works when the block
    is in a ready state.
  - Fix to slurmstepd to not use local variables in a pthread create.
- - In sched/wiki2 - add wiki.conf paramter HostFormat specifying 
+ - In sched/wiki2 - add wiki.conf parameter HostFormat specifying 
    format of hostlists exchanged between Slurm and Moab (experimental).
  - mpi/mvapich: Support Adam Moody's fast MPI initialization protocol 
    (MVAPICH protocol version 8).
--- /dev/null
+++ slurm-llnl-2.2.4/contribs/perlapi/libslurmdb/perl/const-c.inc
@@ -0,0 +1,161 @@
+#define PERL_constant_NOTFOUND	1
+#define PERL_constant_NOTDEF	2
+#define PERL_constant_ISIV	3
+#define PERL_constant_ISNO	4
+#define PERL_constant_ISNV	5
+#define PERL_constant_ISPV	6
+#define PERL_constant_ISPVN	7
+#define PERL_constant_ISSV	8
+#define PERL_constant_ISUNDEF	9
+#define PERL_constant_ISUV	10
+#define PERL_constant_ISYES	11
+
+#ifndef NVTYPE
+typedef double NV; /* 5.6 and later define NVTYPE, and typedef NV to it.  */
+#endif
+#ifndef aTHX_
+#define aTHX_ /* 5.6 or later define this for threading support.  */
+#endif
+#ifndef pTHX_
+#define pTHX_ /* 5.6 or later define this for threading support.  */
+#endif
+
+static int
+constant_18 (pTHX_ const char *name, IV *iv_return) {
+  /* When generated this function returned values for the list of names given
+     here.  However, subsequent manual editing may have added or removed some.
+     SLURMDB_CLASS_BASE SLURMDB_PURGE_BASE SLURMDB_PURGE_DAYS */
+  /* Offset 14 gives the best switch position.  */
+  switch (name[14]) {
+  case 'B':
+    if (memEQ(name, "SLURMDB_CLASS_BASE", 18)) {
+    /*                             ^          */
+#ifdef SLURMDB_CLASS_BASE
+      *iv_return = SLURMDB_CLASS_BASE;
+      return PERL_constant_ISIV;
+#else
+      return PERL_constant_NOTDEF;
+#endif
+    }
+    if (memEQ(name, "SLURMDB_PURGE_BASE", 18)) {
+    /*                             ^          */
+#ifdef SLURMDB_PURGE_BASE
+      *iv_return = SLURMDB_PURGE_BASE;
+      return PERL_constant_ISIV;
+#else
+      return PERL_constant_NOTDEF;
+#endif
+    }
+    break;
+  case 'D':
+    if (memEQ(name, "SLURMDB_PURGE_DAYS", 18)) {
+    /*                             ^          */
+#ifdef SLURMDB_PURGE_DAYS
+      *iv_return = SLURMDB_PURGE_DAYS;
+      return PERL_constant_ISIV;
+#else
+      return PERL_constant_NOTDEF;
+#endif
+    }
+    break;
+  }
+  return PERL_constant_NOTFOUND;
+}
+
+static int
+constant (pTHX_ const char *name, STRLEN len, IV *iv_return) {
+  /* Initially switch on the length of the name.  */
+  /* When generated this function returned values for the list of names given
+     in this section of perl code.  Rather than manually editing these functions
+     to add or remove constants, which would result in this comment and section
+     of code becoming inaccurate, we recommend that you edit this section of
+     code, and use it to regenerate a new set of constant functions which you
+     then use to replace the originals.
+
+     Regenerate these constant functions by feeding this entire source file to
+     perl -x
+
+#!/usr/bin/perl -w
+use ExtUtils::Constant qw (constant_types C_constant XS_constant);
+
+my $types = {map {($_, 1)} qw(IV)};
+my @names = (qw(SLURMDB_CLASSIFIED_FLAG SLURMDB_CLASS_BASE
+	       SLURMDB_PURGE_ARCHIVE SLURMDB_PURGE_BASE SLURMDB_PURGE_DAYS
+	       SLURMDB_PURGE_FLAGS SLURMDB_PURGE_HOURS SLURMDB_PURGE_MONTHS));
+
+print constant_types(), "\n"; # macro defs
+foreach (C_constant ("Slurmdb", 'constant', 'IV', $types, undef, 3, @names) ) {
+    print $_, "\n"; # C constant subs
+}
+print "\n#### XS Section:\n";
+print XS_constant ("Slurmdb", $types);
+__END__
+   */
+
+  switch (len) {
+  case 18:
+    return constant_18 (aTHX_ name, iv_return);
+    break;
+  case 19:
+    /* Names all of length 19.  */
+    /* SLURMDB_PURGE_FLAGS SLURMDB_PURGE_HOURS */
+    /* Offset 14 gives the best switch position.  */
+    switch (name[14]) {
+    case 'F':
+      if (memEQ(name, "SLURMDB_PURGE_FLAGS", 19)) {
+      /*                             ^           */
+#ifdef SLURMDB_PURGE_FLAGS
+        *iv_return = SLURMDB_PURGE_FLAGS;
+        return PERL_constant_ISIV;
+#else
+        return PERL_constant_NOTDEF;
+#endif
+      }
+      break;
+    case 'H':
+      if (memEQ(name, "SLURMDB_PURGE_HOURS", 19)) {
+      /*                             ^           */
+#ifdef SLURMDB_PURGE_HOURS
+        *iv_return = SLURMDB_PURGE_HOURS;
+        return PERL_constant_ISIV;
+#else
+        return PERL_constant_NOTDEF;
+#endif
+      }
+      break;
+    }
+    break;
+  case 20:
+    if (memEQ(name, "SLURMDB_PURGE_MONTHS", 20)) {
+#ifdef SLURMDB_PURGE_MONTHS
+      *iv_return = SLURMDB_PURGE_MONTHS;
+      return PERL_constant_ISIV;
+#else
+      return PERL_constant_NOTDEF;
+#endif
+    }
+    break;
+  case 21:
+    if (memEQ(name, "SLURMDB_PURGE_ARCHIVE", 21)) {
+#ifdef SLURMDB_PURGE_ARCHIVE
+      *iv_return = SLURMDB_PURGE_ARCHIVE;
+      return PERL_constant_ISIV;
+#else
+      return PERL_constant_NOTDEF;
+#endif
+    }
+    break;
+  case 23:
+    if (memEQ(name, "SLURMDB_CLASSIFIED_FLAG", 23)) {
+#ifdef SLURMDB_CLASSIFIED_FLAG
+      *iv_return = SLURMDB_CLASSIFIED_FLAG;
+      return PERL_constant_ISIV;
+#else
+      return PERL_constant_NOTDEF;
+#endif
+    }
+    break;
+  }
+  return PERL_constant_NOTFOUND;
+}
+
--- /dev/null
+++ slurm-llnl-2.2.4/contribs/perlapi/libslurmdb/perl/const-xs.inc
@@ -0,0 +1,90 @@
+void
+constant(sv)
+    PREINIT:
+#ifdef dXSTARG
+	dXSTARG; /* Faster if we have it.  */
+#else
+	dTARGET;
+#endif
+	STRLEN		len;
+        int		type;
+	IV		iv;
+	/* NV		nv;	Uncomment this if you need to return NVs */
+	/* const char	*pv;	Uncomment this if you need to return PVs */
+    INPUT:
+	SV *		sv;
+        const char *	s = SvPV(sv, len);
+    PPCODE:
+        /* Change this to constant(aTHX_ s, len, &iv, &nv);
+           if you need to return both NVs and IVs */
+	type = constant(aTHX_ s, len, &iv);
+      /* Return 1 or 2 items. First is error message, or undef if no error.
+           Second, if present, is found value */
+        switch (type) {
+        case PERL_constant_NOTFOUND:
+          sv =
+	    sv_2mortal(newSVpvf("%s is not a valid Slurmdb macro", s));
+          PUSHs(sv);
+          break;
+        case PERL_constant_NOTDEF:
+          sv = sv_2mortal(newSVpvf(
+	    "Your vendor has not defined Slurmdb macro %s, used",
+				   s));
+          PUSHs(sv);
+          break;
+        case PERL_constant_ISIV:
+          EXTEND(SP, 1);
+          PUSHs(&PL_sv_undef);
+          PUSHi(iv);
+          break;
+	/* Uncomment this if you need to return NOs
+        case PERL_constant_ISNO:
+          EXTEND(SP, 1);
+          PUSHs(&PL_sv_undef);
+          PUSHs(&PL_sv_no);
+          break; */
+	/* Uncomment this if you need to return NVs
+        case PERL_constant_ISNV:
+          EXTEND(SP, 1);
+          PUSHs(&PL_sv_undef);
+          PUSHn(nv);
+          break; */
+	/* Uncomment this if you need to return PVs
+        case PERL_constant_ISPV:
+          EXTEND(SP, 1);
+          PUSHs(&PL_sv_undef);
+          PUSHp(pv, strlen(pv));
+          break; */
+	/* Uncomment this if you need to return PVNs
+        case PERL_constant_ISPVN:
+          EXTEND(SP, 1);
+          PUSHs(&PL_sv_undef);
+          PUSHp(pv, iv);
+          break; */
+	/* Uncomment this if you need to return SVs
+        case PERL_constant_ISSV:
+          EXTEND(SP, 1);
+          PUSHs(&PL_sv_undef);
+          PUSHs(sv);
+          break; */
+	/* Uncomment this if you need to return UNDEFs
+        case PERL_constant_ISUNDEF:
+          break; */
+	/* Uncomment this if you need to return UVs
+        case PERL_constant_ISUV:
+          EXTEND(SP, 1);
+          PUSHs(&PL_sv_undef);
+          PUSHu((UV)iv);
+          break; */
+	/* Uncomment this if you need to return YESs
+        case PERL_constant_ISYES:
+          EXTEND(SP, 1);
+          PUSHs(&PL_sv_undef);
+          PUSHs(&PL_sv_yes);
+          break; */
+        default:
+          sv = sv_2mortal(newSVpvf(
+	    "Unexpected return type %d while processing Slurmdb macro %s, used",
+               type, s));
+          PUSHs(sv);
+        }
--- slurm-llnl-2.2.4.orig/contribs/perlapi/libslurm/perl/step_ctx.c
+++ slurm-llnl-2.2.4/contribs/perlapi/libslurm/perl/step_ctx.c
@@ -434,7 +434,7 @@ task_start_cb(launch_tasks_response_msg_
 
 	hv = newHV();
 	if (launch_tasks_response_msg_to_hv(resp_msg, hv) < 0) {
-		Perl_warn( aTHX_ "failed to prepare paramter for task_start callback");
+		Perl_warn( aTHX_ "failed to prepare parameter for task_start callback");
 		SvREFCNT_dec(hv);
 		return;
 	}
@@ -468,7 +468,7 @@ task_finish_cb(task_exit_msg_t *exit_msg
 
 	hv = newHV();
 	if (task_exit_msg_to_hv(exit_msg, hv) < 0) {
-		Perl_warn( aTHX_ "failed to prepare paramter for task_exit callback");
+		Perl_warn( aTHX_ "failed to prepare parameter for task_exit callback");
 		SvREFCNT_dec(hv);
 		return;
 	}
--- slurm-llnl-2.2.4.orig/contribs/perlapi/libslurm/perl/lib/Slurm.pm
+++ slurm-llnl-2.2.4/contribs/perlapi/libslurm/perl/lib/Slurm.pm
@@ -108,7 +108,7 @@ Then call the desired functions:
 
     $resp = $slurm->load_jobs();
 
-In the following L</"METHODS"> section, if a paramter may be omitted, it will be listed as "param=val" , where "val" is the default value of the paramter if it is not given.
+In the following L</"METHODS"> section, if a parameter may be omitted, it will be listed as "param=val" , where "val" is the default value of the parameter if it is not given.
     
 =head2 DATA STRUCTURES
     
@@ -181,7 +181,7 @@ Get the string describing the specified
 
 =over 2
 
-=item * IN $errno: error number. If ommitted or 0, the error number returned by C<$slurm->get_errno()> will be used.
+=item * IN $errno: error number. If omitted or 0, the error number returned by C<$slurm->get_errno()> will be used.
     
 =item * RET: error string.
 
--- slurm-llnl-2.2.4.orig/src/slurmctld/power_save.c
+++ slurm-llnl-2.2.4/src/slurmctld/power_save.c
@@ -442,7 +442,7 @@ static void _clear_power_config(void)
 	FREE_NULL_BITMAP(exc_node_bitmap);
 }
 
-/* Initialize power_save module paramters.
+/* Initialize power_save module parameters.
  * Return 0 on valid configuration to run power saving,
  * otherwise log the problem and return -1 */
 static int _init_power_config(void)
--- slurm-llnl-2.2.4.orig/testsuite/expect/test12.2
+++ slurm-llnl-2.2.4/testsuite/expect/test12.2
@@ -42,7 +42,7 @@ set job_id      0
 set matches     0
 set aix         0
 
-# job paramters
+# job parameters
 set mem_size    1024000
 set sleep_time  21
 set ret_code    42
--- slurm-llnl-2.2.4.orig/testsuite/expect/test8.5
+++ slurm-llnl-2.2.4/testsuite/expect/test8.5
@@ -40,7 +40,7 @@ set file_err    "test$test_id.error"
 set job_id      0
 set matches     0
 
-# job paramters
+# job parameters
 set sleep_time 1
 
 proc run_and_test { size } {
--- slurm-llnl-2.2.4.orig/testsuite/expect/test8.8
+++ slurm-llnl-2.2.4/testsuite/expect/test8.8
@@ -38,7 +38,7 @@ set exit_code   0
 set job_id      0
 set matches     0
 
-# job paramters
+# job parameters
 set sleep_time  5
 
 
--- slurm-llnl-2.2.4.orig/testsuite/expect/test8.6
+++ slurm-llnl-2.2.4/testsuite/expect/test8.6
@@ -39,7 +39,7 @@ set file_in     "test$test_id.input"
 set job_id      0
 set matches     0
 
-# job paramters
+# job parameters
 set sleep_time  5
 
 # make a bunch of blocks of the specified size (node_cnt)
